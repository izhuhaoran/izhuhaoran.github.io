<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OpenMP学习笔记</title>
    <link href="/2023/01/24/CPP_Note/OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/24/CPP_Note/OpenMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="openmp学习笔记">OpenMP学习笔记</h1><p>OpenMP是目前常见的C++多线程并行库，本笔记主要记录对于OpenMP的一些学习经验，平台为ubuntu</p><h2 id="openmp编译">1. OpenMP编译</h2><p>本节以test.C为例，说明如何编译使用OpenMP的c++代码</p><ol type="1"><li><strong>g++编译选项</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -fopenmp test.C -o testDemo<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>CMake编译</strong></li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><span class="hljs-keyword">project</span>(testDemo)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<br><span class="hljs-comment"># set(CMAKE_VERBOSE_MAKEFILE ON)</span><br><span class="hljs-comment"># set(CMAKE_BUILD_TYPE &quot;Debug&quot;)</span><br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Release&quot;</span>)<br><br><span class="hljs-comment"># set(CMAKE_CXX_FLAGS &quot;-O3 -Wall -DOPENMP&quot;) </span><br><br><span class="hljs-comment"># openMP settings</span><br><span class="hljs-keyword">FIND_PACKAGE</span>(OpenMP REQUIRED)<br><span class="hljs-keyword">if</span> (OPENMP_FOUND)<br>    <span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;OPENMP FOUND&quot;</span>)<br>    <span class="hljs-keyword">set</span>(CMAKE_C_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_C_FLAGS&#125; $&#123;OpenMP_C_FLAGS&#125;&quot;</span>)<br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;OpenMP_CXX_FLAGS&#125;&quot;</span>)<br>    <span class="hljs-keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; $&#123;OpenMP_EXE_LINKER_FLAGS&#125;&quot;</span>)<br><span class="hljs-keyword">endif</span> ()<br><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> ./<span class="hljs-keyword">test</span>.C)<br></code></pre></td></tr></table></figure><p>需要注意的是：CMake也可以直接通过设置CMAKE_CXX_FLAGS，添加-fopenmp实现编译OpenMP的c++代码，但推荐使用如上的FIND_PACKAGE方法</p><h2 id="openmp常用方法">2. OpenMP常用方法</h2><p>待补充</p><h2 id="openmp高级方法">3. OpenMP高级方法</h2><p>待补充</p>]]></content>
    
    
    <categories>
      
      <category>CPP_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>ubuntu</tag>
      
      <tag>openmp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cilk plus学习记录</title>
    <link href="/2023/01/24/CPP_Note/cilkplus%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/24/CPP_Note/cilkplus%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="cilk-plus学习记录">cilk plus学习记录</h1><p>cilk plus是c/c++的一个并行多线程处理库，主要为Intel&amp;MIT开发，官网地址：http://cilkplus.github.io/</p><p>目前gcc/g++新版本中已经移除cilk plus，最新cilk研究为MIT的以clang llvm为编译的open cilk，官网地址为：https://www.opencilk.org/</p><h2 id="cilk-plus安装使用">cilk plus安装使用</h2><p>平台为ubuntu，在<strong>gcc/g++-5及更老版本</strong>编译器直接支持cilk plus，直接可以编译使用, 编译命令如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -fcilkplus -lcilkrts -O3 ./test.cpp -o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>在<strong>gcc/g++-7版本</strong>支持cilk plus，但是缺少相关cilk头文件，可以使用cp命令，将gcc-5的cilk头文件复制过来，然后可以正常编译使用,</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 复制cilk h文件</span><br>cp -r <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/gcc/</span>x86_64-linux-gnu<span class="hljs-regexp">/5/i</span>nclude<span class="hljs-regexp">/cilk /u</span>sr<span class="hljs-regexp">/lib/g</span>cc<span class="hljs-regexp">/x86_64-linux-gnu/</span><span class="hljs-number">7</span><span class="hljs-regexp">/include/</span>cilk<br><br><span class="hljs-comment"># g++编译    </span><br>g++ -fcilkplus -lcilkrts -O3 ./test.cpp -o test<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CPP_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>ubuntu</tag>
      
      <tag>cilkplus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github-VScode在线web编辑器-github.dev</title>
    <link href="/2023/01/24/Git_Note/Github-VScode%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91/"/>
    <url>/2023/01/24/Git_Note/Github-VScode%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h1 id="github在线web编辑器-github.dev">github在线web编辑器-github.dev</h1><blockquote><p>内容来源于<a href="https://docs.github.com/en/codespaces/the-githubdev-web-based-editor">githubdev官方文档</a></p></blockquote><h2 id="github-dev-简介">1. github-dev 简介</h2><p>github 提供了beta版的web编辑器github.dev, 引入了一种完全在浏览器中运行的轻量级编辑体验。不过<strong>必须登录到GitHub.com才能使用github.dev编辑器</strong>。通过github.dev编辑器，你可以从GitHub浏览文件和源代码库，并进行和提交代码修改。你可以在编辑器中打开任何储存库、分叉或拉动请求。</p><p>github.dev编辑器在GitHub.com上向所有人免费提供。github.dev编辑器提供了Visual Studio Code的许多好处，如搜索、语法高亮和源控制视图。你也可以使用 "设置同步 "来与编辑器同步你自己的VS Code设置。</p><!-- ![202301242029872](https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/GitNoteImgs/202301242029872.png) --><p>github.dev编辑器完全在浏览器的沙盒中运行。编辑器并不克隆仓库，而是使用GitHub Repositories扩展来实现你将使用的大部分功能。注意：<strong>在你提交之前，你的工作都保存在浏览器的本地存储中，你应该定期提交你的修改，以确保它们总是可以被访问。</strong></p><blockquote><p>当你打开一个github仓库网页的dev编辑时，直接退出在线编辑器后，你所新加的任何change都会被浏览器保留，但不会自动推送到仓库，需要及时的在dev的web-vscode环境中push或者放弃更改。</p></blockquote><h2 id="github-dev-打开方式">2. github-dev 打开方式</h2><p>官方提供了四种进入dev-web的方法：</p><ul><li><p>要在同一个浏览器标签页中打开该仓库，在浏览 GitHub 上的任何仓库或pull请求时按键盘上的<code> . </code>键（句号键）</p></li><li><p>要在新的浏览器标签页中打开该仓库，按<code> &gt; </code>键（shift+句号键）</p></li><li><p>直接在浏览器地址栏将将URL从 "github.com/.... "改为 "github.dev/...."</p></li><li><p>在github查看仓库具体某个文件时，点击修改小铅笔旁边的下拉菜单并选择在github.dev中打开</p><figure><img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/GitNoteImgs/202301242029587.png" alt="" /><figcaption>202301242029872</figcaption></figure></li></ul><h2 id="后续正常使用vscode">3. 后续正常使用Vscode</h2><p>进入github-dev之后就是一个简化web版的vscode编辑器(大部分人对它应该不陌生), 你可以按需安装扩展，编辑文件等等，然后使用vscode自带的git管理器直接进行版本管理即可，详细信息请继续参照<a href="https://docs.github.com/en/codespaces/the-githubdev-web-based-editor">githubdev官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Git_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理练习题</title>
    <link href="/2023/01/23/Course_Note/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2023/01/23/Course_Note/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="数字图像处理练习题">数字图像处理练习题</h1><h3 id="图像放大缩小">1. 图像放大缩小</h3><ul><li><p><mark><strong>题目</strong></mark>： <strong>设一幅大小为M×N的灰度图像I中，现要变成（放大或缩小）为 P×Q的图像J，请写出J的生成算法。【参考函数：imresize】</strong></p></li><li><p><mark><strong>解答</strong></mark>：</p><p><strong>算法流程为</strong>：</p><ol type="1"><li>通过原始图像大小和目标图像大小，确定横轴纵轴缩放因子<span class="math inline">\(t_1, t_2\)</span>，并创建目标图像。</li><li>对目标图像的一个像素位置<span class="math inline">\((x&#39;,y&#39;)\)</span>，根据缩放因子算出映射在原始图像的位置<span class="math inline">\((x,y)\)</span></li><li>对于整数值<span class="math inline">\((x,y)\)</span>位置，直接将原始图像素值赋给目标图<span class="math inline">\((x&#39;,y&#39;)\)</span>位置，对于非整数<span class="math inline">\((x,y)\)</span>位置，使用插值法（双线性内插法）利用原始图<span class="math inline">\((x,y)\)</span>相邻四个像素值计算目标像素点值赋给目标图<span class="math inline">\((x&#39;,y&#39;)\)</span>位置。</li><li>重复2-3步骤直到目标图所有像素写完毕。</li></ol><p><strong>算法具体运算细节即插值方法描述</strong>：设原始图像用<span class="math inline">\(f(x,y)\)</span>表示，原图像大小为<span class="math inline">\(M×N\)</span>，缩放后的图像为<span class="math inline">\(f(x&#39;,y&#39;)\)</span>，其大小为<span class="math inline">\(P×Q\)</span>, 则在x方向缩放因子<span class="math inline">\(t_1=P/M\)</span>, y轴方向上的缩放因子为<span class="math inline">\(t_2=Q/N\)</span>。则对于目标图像<span class="math inline">\(f(x&#39;,y&#39;)\)</span>来说，对于每个像素点位置<span class="math inline">\((x&#39;,y&#39;)\)</span>,其映射再原图上的坐标位置<span class="math inline">\((x,y)\)</span>有如下关系：<span class="math display">\[x=x&#39;/t_1 ,y=y&#39;/t_2\]</span> (1) 对于上式映射的<span class="math inline">\((x,y)\)</span>都是整数的点，直接将原图对应位置像素值赋给目标图<span class="math inline">\((x&#39;,y&#39; )\)</span>位置。(2) 对于<span class="math inline">\((x,y)\)</span>存在小数的情况，则需要使用插值(插值方法有很多，这里使用双线性内插法)法获得对应坐标值，这样对目标图每一个坐标都寻找到用原图像素映射的值，缩放结果图也便形成。</p><p><strong>双线性内插法介绍</strong>：需要找到原图中与<span class="math inline">\((x,y)\)</span>位置最近的四个点设为<span class="math inline">\(Q_{11}(x_{1}, y_{1})\)</span>, <span class="math inline">\(Q_{12}(x_{1}, y_{2})\)</span>, <span class="math inline">\(Q_{21}(x_{2}, y_{1})\)</span>, <span class="math inline">\(Q_{22}(x_{2}, y_{2})\)</span>。其位置关系如下： <img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814856.png" width="30%"/> <!-- <img src="/images/CourseNoteImgs/568080220239569.png" width="30%"> --> 如图所示，我们要求P点位置像素值，所以先用关于X的单线性插值去分别计算R1、R2的像素值： &lt;img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814131.png" width="50%/&gt; <!-- <img src="/images/CourseNoteImgs/77531620247602.png" width="50%"> --> 再使用关于y方向的单线性插值计算P点的像素值，得出： <img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814100.png" width="50%"/> <!-- <img src="/images/CourseNoteImgs/20191026142817345.png" width="50%"> --> 在上面的等式中的字母y1、y2、y都是已知的，f(x,y1)与f(x,y2）即为上一个式子中求出的R1、R2像素值。</p></li></ul><p> </p><h3 id="中值滤波">2. 中值滤波</h3><ul><li><p><mark><strong>题目1</strong></mark>：<strong>请写出使用大小为3×3的模板对图像I进行中值滤波，生成图像J的方法。</strong></p></li><li><p><mark><strong>解答</strong></mark>：算法流程描述如下：</p><ol type="1"><li>获得源图像的首地址及图像的宽和高</li><li>初始化目的图像，用以暂存结果图像，并初始化为0</li><li>初始模板中心在(2,2)位置，逐个扫描图像中的像素点，将其3*3邻域各元素的像素值从小到大进行排序，将求得到的中间值赋值给目标图像中与当前点对应的像素点。</li><li>循环步骤3,行列滑动模板位置，直到处理完源图像的全部像素点</li></ol></li></ul><blockquote><p>注意：步骤3中的循环扫描不能从(1,1)位置开始，模板为3*3，初始状态中心应该在(2,2)位置</p></blockquote><p><strong>matlab代码如下：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear;<br>A=imread(<span class="hljs-string">&#x27;num22&quot;,&#x27;</span>bmp);<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br>B=rgb2 gray(A);<br>subimage(B);<br>title(<span class="hljs-string">&#x27;处理前的图);</span><br><span class="hljs-string"></span><br><span class="hljs-string">C=B;</span><br><span class="hljs-string">xsize=size(B);</span><br><span class="hljs-string">for k=2:(xsize(1)-1)</span><br><span class="hljs-string">    for j=2:(xsize(2)-1)</span><br><span class="hljs-string">        t=B(k-1:k+1,j-1:j+1);</span><br><span class="hljs-string">        C(k.j)=median(t(1:9));</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">subplot(1,2,2);</span><br><span class="hljs-string">subimage(C);</span><br><span class="hljs-string">title(&#x27;</span>处理后的图);<br></code></pre></td></tr></table></figure><p> </p><ul><li><p><mark><strong>题目2</strong></mark>：<strong>简述中值滤波的特性和适用场合</strong>。</p></li><li><p><mark><strong>解答</strong></mark>：中值滤波是一种非线性滤波，由于它在实际运算过程中并不需要图像的统计特性，所以比较方便。中值滤波首先是被应用在一维信号处理技术中，后来被二维图像信号处理技术所应用。在一定的条件下，可以克服线性滤波器所带来的图像细节模糊，而且对滤除脉冲干扰及图像扫描噪声最为有效。中值滤波的目的是保护图像边缘的同时去除噪声。</p></li></ul><p> </p><h3 id="傅里叶变换">3. 傅里叶变换</h3><ul><li><p><mark><strong>题目1</strong></mark>： <strong>写出一维、二维离散傅立叶变换、反变换的计算公式。傅立叶系数的物理含义是什么？简述对一个二维图像进行快速傅里叶变换的方法。</strong></p></li><li><p><mark><strong>解答</strong></mark>：</p><p><strong>一维傅里叶变换(上)与反变换（下）</strong>：</p><p><!-- <img src="/images/CourseNoteImgs/1.png" width="35%"> --> <img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814090.png" width="35%"/></p><p><strong>二维傅里叶变换(上)与反变换（下）</strong>：</p><p><!-- <img src="/images/CourseNoteImgs/2.png" width="45%"> --> <img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814347.png" width="45%"/></p><p><strong>傅立叶系数的物理含义</strong>：</p><p>傅里叶变换可以看做“数学的棱镜”，将时域信号分解为若干不同频率的频域信号，而不同傅立叶系数则代表了分解的不同频率信号的振幅。</p><p><strong>二维图像进行快速傅里叶变换简述步骤</strong>：</p><p>假设图像为一个M行N列的二维图像，用<span class="math inline">\(f(x,y)\)</span>表示, FFT变换结果为<span class="math inline">\(F(u,v)\)</span><strong>简述对其二维FFT步骤</strong>为：</p><ol type="1"><li>根据基2快速傅里叶变换的计算要求，需要图像的行数M、列数N均满足2的n次方，如果不满足，在计算FFT之前先要对图像补零以满足2的n次。</li><li>先按列变量y做一次长度为N的一维快速傅里叶变换FFT得到<span class="math inline">\(F(x,v)\)</span>: <span class="math display">\[F(x,v)=\frac{1}{N} \sum_{y=0}^{N-1}{f(x,y)e^{-j2\pi vy/N}}, v=0,1,..,N-1 \]</span></li><li>再将第2步骤所得结果按x做一次长度为M的一维快速傅里叶变换得到最终结果<span class="math inline">\(F(u,v)\)</span>: <span class="math display">\[F(u,v)=\frac{1}{M} \sum_{x=0}^{N-1}{F(x,v)e^{-j2\pi ux/M}}, u=0,1,..,N-1 \]</span></li></ol><p>上述<strong>流程中使用了一维FFT</strong>，原理主要是将长序列DFT分解为若干短序列DFT，利用旋转因子W的周期性，对称性，可约性减少计算量。 <strong>一维快速傅里叶(基2时分)原理具体介绍如下</strong>：</p><ol type="1"><li><p>假设信号序列为<span class="math inline">\(x(n)\)</span>，将其分解为偶数和奇数两个子序列即<span class="math inline">\(x(n)=x_1(n)+x_2(n)\)</span>, 两个子序列的长度都是N/2，<span class="math inline">\(x_1(n)\)</span>是偶数序列，<span class="math inline">\(x_2(n)\)</span>是奇数序列，则有： <img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814621.png" width="70%"/> <!-- <img src="/images/CourseNoteImgs/3.png" width="70%"> --></p></li><li><p>其中<span class="math inline">\(X_1(k)\)</span>和<span class="math inline">\(X_2(k)\)</span>分别为<span class="math inline">\(x_1(n)\)</span>和<span class="math inline">\(x_2(n)\)</span>的 N/2 点DFT。由于<span class="math inline">\(X_1(k)\)</span>和<span class="math inline">\(X_2(k)\)</span>均以 N／2为周期，且<span class="math inline">\(W_N^{k+N/2}=-W_N^k\)</span>，所以<span class="math inline">\(X(k)\)</span>又可表示为： <img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814879.png" width="70%"/> <!-- <img src="/images/CourseNoteImgs/4.png" width="70%"> --> 即我们把一个N点的DFT拆成了两个N/2的DFT。</p></li><li><p>上述步骤2只是一次划分，经过若干次递归迭代二分划分，则原本的DFT（普通傅里叶）的<span class="math inline">\(O(n^2)\)</span>时间复杂度 降为FFT（快速傅里叶）的<span class="math inline">\(O(n·log n)\)</span>。</p></li></ol><p> </p></li></ul><h3 id="七边缘检测">七、边缘检测</h3><h4 id="canny算子">1、canny算子</h4><ul><li><p><strong>题目</strong>：<strong>请写出Canny算子检测边缘的详细步骤。</strong></p></li><li><p><strong>解答</strong>：Canny边缘检测算法可以分为以下5个步骤</p><ol type="1"><li>应用高斯滤波来平滑图像，目的是去除噪声。 总结一下这一步：高斯滤波其实就是将所指像素用周围的像素的某种均值代替(即卷积核)，卷积核尺寸越大，去噪能力越强，因此噪声越少，但图片越模糊，canny检测算法抗噪声能力越强，但模糊的副作用也会导致定位精度不高。</li><li>找寻图像的强度梯度。</li><li>根据梯度方向，对梯度强度幅值应用非最大抑制（non-maximum suppression），以消除边缘检测带来的杂散响应。</li><li>用双阈值算法检测检测来确定真实的和潜在的边缘，并通过抑制孤立的弱边缘最终形成结果边缘.<ul><li>选取系数TH和TL，比率为2:1或3:1。（一般取TH=0.3或0.2,TL=0.1）；</li><li>将小于低阈值的点抛弃，赋0；将大于高阈值的点立即标记（这些点为确定边缘点），赋1或255；</li><li>将小于高阈值，大于低阈值的点使用8连通区域确定（即：只有与TH像素连接时才会被接受，成为边缘点，赋 1或255）</li></ul></li></ol></li></ul><p> </p><h3 id="八形态运算">八、形态运算</h3><h4 id="图像腐蚀">1、图像腐蚀</h4><ul><li><p><strong>题目</strong>：<strong>设有一幅二值图像，采用 3×3的结构元（每个元素均为1）对其进行腐蚀操作，试写出得到结果图像的方法</strong>。</p></li><li><p><strong>解答</strong>：腐蚀处理的结果是使原来的二值图像减小一圈, 原图A被结构B腐蚀的定义如下，z代表B的中心位置:</p><p><span class="math display">\[A\bigodot B=\{z|  (B)_z \subseteq A \}\]</span> 可以理解为，移动结构B，如果结构B完全属于原图A的区域内，则保存该位置点，所有满足条件的点构成结构A被结构B腐蚀的结果。</p><p>用结构体B对原图A进行腐蚀的整个过程如下： ⑴ 将3*3的结构元B在A中移动，即让B的中心循环扫描图像A的每一个像素。 ⑵ 用结构元素B的每个位置与其覆盖的二值图像同样位置做“与”操作 ⑶ 如果(2)结果中所有像素结果都为1，也即结构体B完全包含在A中，则此时目标图像对应B的中心位置像素为1，否则为0。</p><p>示例结果如下, 有颜色代表像素为1，空白代表像素为0 ： <img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814371.png"/> <!-- ![8.1](/images/CourseNoteImgs/363143510221145.png) --></p></li></ul><p> </p><h4 id="孔洞填充">2、孔洞填充</h4><ul><li><p><strong>题目</strong>：<strong>试写出孔洞填充的算法。对二值图像中所有被白色区域包围（封闭）的黑色像素即为孔洞。</strong></p></li><li><p><strong>解答</strong>：孔洞填充的公式为：</p><p><span class="math display">\[X_k=(X_{k-1} \oplus B) \cap A^c \qquad k=1,2,3,...\]</span></p><p>设原包含孔洞的图像为A，原图补集为<span class="math inline">\(A^c\)</span>，用于填充膨胀的结构体为B，则<strong>孔洞填充算法流程</strong>：</p><ol type="1"><li>将原图像A每个像素取反，获得补集原图像的补集记作<span class="math inline">\(A^c\)</span>，用来限制膨胀结果在孔洞内，防止膨胀超出孔洞区域范围；</li><li>在原图孔洞中选择一个初始点，使用结构体B膨胀该点；</li><li>将膨胀后的结果与原图补集<span class="math inline">\(A^c\)</span>相交，得到该轮次的结果<span class="math inline">\(X_k\)</span>。</li><li>在原图孔洞中移动到下一个点，重复2~4步，直到第K步和第K+1步结果相同，填充完毕。</li></ol><p>上述算法步骤中使用了膨胀操作，下面简述<strong>膨胀操作</strong>过程： 膨胀处理的结果是使原来的二值图像扩大一圈, 原图A被结构B膨胀的定义如下，z代表B的中心位置:</p><p><span class="math display">\[A\bigoplus B=\{z|(\hat{B})_z \bigcap A \neq \emptyset\}\]</span> 上式中<span class="math inline">\((\hat{B})_z\)</span>是结构体关于中心圆点反转的结构，膨胀可以理解为，移动结构B的反转结构<span class="math inline">\((\hat{B})_z\)</span>，如果与原图A存在重叠区域，也即交集不为空，则此时结构体中心位置对应在目标图结果中处像素为1，反之没有交集则为0。</p></li></ul><p> </p><h4 id="粘连区域断开">3、粘连区域断开</h4><ul><li><p><strong>题目</strong>：<strong>设有两个白色区域，被一条细小的白线所连接，试设计一种算法，消除两个区域之间的细线，使两个区域分开。</strong></p></li><li><p><strong>解答</strong>：使用开运算即可，开运算等于对原图先腐蚀后膨胀，可以用来消除小物体、在纤细点处分离物体、消除物体周围的毛刺等。设原图为A，结构体为B开运算的公式为：</p><p><span class="math display">\[A \bigcirc B=(A\odot B) \oplus B\]</span></p><p>分割两个细小白线连接的白色区域的步骤如下：</p><ol type="1"><li>设置开运算结构B为N*N, N的大小根据细线的宽度而更改，要比细线宽度大。</li><li>先对原图A使用结构体B进行腐蚀运算。</li><li>对2的结果再次使用结构体B进行膨胀运算。</li></ol><blockquote><p>注意，上述开运算步骤中使用了腐蚀和膨胀运算，这两种算法见前两题图像腐蚀和孔洞填充中介绍，这里不再赘述。</p></blockquote></li></ul><p> </p><h4 id="计算凸壳">4、计算凸壳</h4><ul><li><p><strong>题目</strong>：<strong>计算包围给定点集的最小凸多边形。</strong></p></li><li><p><strong>解答</strong>：采用安德鲁算法计算最小凸包，流程简述如下： （1）将给定的点集合按照x坐标升序排列。x相同的话，按照y坐标升序排列 （2）创建凸包的上部U点序列：默认将x最小的两个点加入上凸包U，再将排序后的点按照x坐标从小到大的顺序依次加入凸包U，<strong>并检查U是否仍然为凸包</strong>。如果新加入的点使得U不再是凸多边形，那么就逆序依次删除已经插入U的点，直到U为凸多边形。 （3）创建凸包的下部L点序列：默认将x最大的两个点加入下凸包L, 再将排序后的点按照x坐标从大到小的顺序加入凸包L，<strong>并检查L是否仍然为凸包</strong>。如果新加入的点使得L不再是凸多边形，那么就逆序删除已经插入L的点，直到L为凸多边形。 （4）连接凸包的上部和下部： 最终外接凸多边形点集为凸包上部的点序列+凸包下部逆置后的点序列(下部形成是按照x从大到小，要逆序形成从小到大的序列)，每两个点之间连线，最后一个点和第一个点连线即是最终外接凸多边形。</p><p><strong>检查是否为凸包的方法如下：</strong> 设将要加入点<span class="math inline">\(P_2\)</span>，凸包集中上一轮加入的节点为<span class="math inline">\(P_1\)</span>, 上上一轮加入的节点为<span class="math inline">\(P_0\)</span> , 则形成两个向量： <span class="math inline">\(\vec{a}=P_0 \rightarrow P_1\)</span>和 <span class="math inline">\(\vec{b}=P_0 \rightarrow P_2\)</span>。如果<span class="math inline">\(\vec{a} \times \vec{b} &lt; 0\)</span>, 则说明第二个向量<span class="math inline">\(\vec{b}\)</span>位于第一个向量<span class="math inline">\(\vec{a}\)</span>的逆时针处, 此时新加入节点<span class="math inline">\(P_2\)</span>会使结果不再是凸边形，需要逆序删除已经插入的点，直到加入<span class="math inline">\(P_2\)</span>后，保持凸包。</p><p>上述判断方法示意图如下, 此时加入P2会使第二个向量<span class="math inline">\(\vec{b}\)</span>位于第一个向量<span class="math inline">\(\vec{a}\)</span>的逆时针处，凸包被破坏，需要逆序删除P1点。 <img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/CourseNoteImgs/202301241814617.png"/> <!-- ![34](/images/CourseNoteImgs/412055816236828.png) --></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Course_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中 cilkplus openmp for多线程循环效率对比</title>
    <link href="/2023/01/23/CPP_Note/for_cilk_openmp%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94/"/>
    <url>/2023/01/23/CPP_Note/for_cilk_openmp%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="c中-cilkplus-openmp-for多线程循环效率对比">c++中 cilkplus openmp for多线程循环效率对比</h1><p>本文为初步测试多线程for不同库之间的效率对比，cilkplus为Intel的一个多线程库(gcc 7.5后移除了该库)，OpenMP为使用较多的多线程库，本文测试了在存在数据竞争时的不同线程库的效率，平台为ubuntu。</p><p><strong>注意：本测试只是初步测试，数据可能存在误差，编译器使用g++-7.5，编译优化为-O3</strong></p><h2 id="测试代码">1 测试代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cilk/cilk.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;parallel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gettime.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// CAS func (atomic)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ET</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">CAS</span><span class="hljs-params">(ET *ptr, ET oldv, ET newv)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(ET) == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> __sync_bool_compare_and_swap((<span class="hljs-type">bool</span>*)ptr, *((<span class="hljs-type">bool</span>*)&amp;oldv), *((<span class="hljs-type">bool</span>*)&amp;newv));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(ET) == <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-keyword">return</span> __sync_bool_compare_and_swap((<span class="hljs-type">int</span>*)ptr, *((<span class="hljs-type">int</span>*)&amp;oldv), *((<span class="hljs-type">int</span>*)&amp;newv));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sizeof</span>(ET) == <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">return</span> __sync_bool_compare_and_swap((<span class="hljs-type">long</span>*)ptr, *((<span class="hljs-type">long</span>*)&amp;oldv), *((<span class="hljs-type">long</span>*)&amp;newv));<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;CAS bad length : &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(ET) &lt;&lt; std::endl;<br>    <span class="hljs-built_in">abort</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ET</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">writeAdd</span><span class="hljs-params">(ET *a, ET b)</span> </span>&#123;<br>  <span class="hljs-keyword">volatile</span> ET newV, oldV;<br>  <span class="hljs-keyword">do</span> &#123;oldV = *a; newV = oldV + b;&#125;<br>  <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(a, oldV, newV));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> num[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++)&#123;<br>        num[i] = i;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init num list over.\n&quot;</span>);<br><br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">startTime</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> t = (i * <span class="hljs-number">12</span>) % <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">int</span> tmp = num[t];<br>        sum += tmp;<br>    &#125;<br>    <span class="hljs-built_in">nextTime</span>(<span class="hljs-string">&quot;base time: &quot;</span>);<br>    cout&lt;&lt;sum&lt;&lt;endl;<br><br>    <span class="hljs-comment">// openmp reduce</span><br>    sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">startTime</span>();<br>    <span class="hljs-built_in">omp_set_num_threads</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for reduction(+: sum)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> t = (i * <span class="hljs-number">12</span>) % <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">int</span> tmp = num[t];<br>        sum += tmp;<br>    &#125;<br>    <span class="hljs-built_in">nextTime</span>(<span class="hljs-string">&quot;omp time: &quot;</span>);<br>    cout&lt;&lt;sum&lt;&lt;endl;<br>    <br>    <span class="hljs-comment">// openmp &amp; CAS</span><br>    sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">startTime</span>();<br>    <span class="hljs-built_in">omp_set_num_threads</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> t = (i * <span class="hljs-number">12</span>) % <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">int</span> tmp = num[t];<br>        <span class="hljs-built_in">writeAdd</span>(&amp;sum, tmp);<br>    &#125;<br>    <span class="hljs-built_in">nextTime</span>(<span class="hljs-string">&quot;omp &amp; CAS time: &quot;</span>);<br>    cout&lt;&lt;sum&lt;&lt;endl;    <br><br>    <span class="hljs-comment">// cilk test</span><br>    sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">setWorkers</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">startTime</span>();<br><br>    <span class="hljs-built_in">cilk_for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) <br>    &#123;<br>        <span class="hljs-type">int</span> t = (i * <span class="hljs-number">12</span>) % <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">int</span> tmp = num[t];<br>        <span class="hljs-built_in">writeAdd</span>(&amp;sum, tmp);<br>    &#125;<br>    <span class="hljs-built_in">nextTime</span>(<span class="hljs-string">&quot;cilk &amp; CAS time: &quot;</span>);<br>    cout&lt;&lt;sum&lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试运行时间结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">init</span> num list over.<br><span class="hljs-attribute">base</span> time:  : <span class="hljs-number">8</span>.<span class="hljs-number">11</span>e-<span class="hljs-number">06</span><br><span class="hljs-attribute">498000</span><br><span class="hljs-attribute">omp</span> time:  : <span class="hljs-number">0</span>.<span class="hljs-number">000205</span><br><span class="hljs-attribute">498000</span><br><span class="hljs-attribute">omp</span> &amp; CAS time:  : <span class="hljs-number">8</span>.<span class="hljs-number">7</span>e-<span class="hljs-number">05</span><br><span class="hljs-attribute">498000</span><br><span class="hljs-attribute">cilk</span> &amp; CAS time:  : <span class="hljs-number">0</span>.<span class="hljs-number">000253</span><br><span class="hljs-attribute">498000</span><br></code></pre></td></tr></table></figure><ul><li>本测试中直接for循环时间更短是由于本测试线程数只有5，且本测试for循环中代码逻辑较为简单，实际需求开发中for中往往逻辑更加复杂，并行的收益一般都会大于收益。</li><li>本实验中，存在数据竞争(多线程同时写sum变量)，直接并行会导致结果出错，本实验提供了自实现的CAS操作，同时OpenMP提供reduction操作也可以解决简单的数据竞争。</li></ul><h2 id="结果总结">2 结果总结</h2><ul><li>OpenMP提供的reduction效率不高，但不如使用CAS原子操作</li><li>OpenMP的效率要略高于cilkplus</li></ul>]]></content>
    
    
    <categories>
      
      <category>CPP_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>ubuntu</tag>
      
      <tag>openmp</tag>
      
      <tag>cilkplus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++重载终端输出到文件</title>
    <link href="/2023/01/23/CPP_Note/c++%E9%87%8D%E5%AE%9A%E5%90%91%E7%BB%88%E7%AB%AF%E6%89%93%E5%8D%B0%E5%88%B0%E6%96%87%E4%BB%B6/"/>
    <url>/2023/01/23/CPP_Note/c++%E9%87%8D%E5%AE%9A%E5%90%91%E7%BB%88%E7%AB%AF%E6%89%93%E5%8D%B0%E5%88%B0%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="c重载终端输出到文件">c++重载终端输出到文件</h1><p>在c++程序编写中，有时需要将终端的打印信息保存为日志文件，便于程序测试和debug，下面记录两种建议方法实现重定向打印信息</p><ol type="1"><li>在linux系统下，可以直接使用终端命令重定向程序输出到文件中</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./testOut2File &gt; ./log.txt<br></code></pre></td></tr></table></figure><p>上述命令中./testOut2File为可执行文件，"&gt;"表示重定向输出到./log.txt文件中</p><ol start="2" type="1"><li>使用"cstdio"头文件中的freopen()函数与fclose()函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 重定向标准输出到 output.log</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;./log.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;This is a test.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    <span class="hljs-built_in">fclose</span>(stdout);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是需要在main函数的最后使用fclose(stdout)将输出流恢复，否则可能导致程序崩溃。</p>]]></content>
    
    
    <categories>
      
      <category>CPP_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c/c++</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu多用户共享文件夹、文件</title>
    <link href="/2023/01/23/Linux_Note/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/01/23/Linux_Note/%E5%A4%9A%E7%94%A8%E6%88%B7%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu多用户共享文件夹文件操作">ubuntu多用户共享文件夹、文件操作</h1><blockquote><p>linux多用户同时共享一个文件</p></blockquote><p><strong>主要思路就是用root权限创建文件夹，然后给文件夹分配用户组的权限，然后把所有需要访问这个文件夹的用户加到这个用户组当中来</strong></p><p><strong>例如有alex，bob两个用户，互相无法访问对方的home~文件夹，为了共享文件，可以让root用户在/home中创建一个shared文件夹，然后创建一个用户组dev01</strong></p><p>在root或者sudo下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">groupadd</span> dev01<br></code></pre></td></tr></table></figure><p>然后将需要共享文件的用户添加到dev01这个用户组</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">usermod -<span class="hljs-selector-tag">a</span> -G dev01 alex<br>usermod -<span class="hljs-selector-tag">a</span> -G dev01 bob<br></code></pre></td></tr></table></figure><p>创建用户组之后并为文件夹更改组</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/home/</span>dev_shared<br>chgrp dev01 <span class="hljs-regexp">/home/</span>dev_shared<br></code></pre></td></tr></table></figure><p>接下来更改文件夹权限，使得owner以及用户组可以访问,+s是为了确保之后添加进去的文件夹也继承同样的权限</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">chmod <span class="hljs-number">777</span> /home/dev_shared<br>chmod +s /home/dev_shared<br><br><span class="hljs-comment">// 补充若是已有的文件夹，需要加-R递归执行</span><br><span class="hljs-number">1</span> 修改用户组<br>chgrp <span class="hljs-selector-attr">[-R]</span> group test<span class="hljs-selector-class">.log</span><br><span class="hljs-function"><span class="hljs-title">chgrp</span><span class="hljs-params">(change group)</span></span> <span class="hljs-built_in">-R</span>(递归执行) 用户组名 文件/文件夹名（若非当前路径下的文件就写文件路径）<br><br><span class="hljs-number">2</span> 修改用户<br>chown <span class="hljs-selector-attr">[-R]</span> owner test<span class="hljs-selector-class">.log</span><br><span class="hljs-function"><span class="hljs-title">chown</span><span class="hljs-params">(change owner)</span></span> <span class="hljs-built_in">-R</span>(递归执行) 用户名 文件/文件夹名（若非当前路径下的文件就写文件路径）<br><br><span class="hljs-number">3</span> 修改用户组和用户<br>chown <span class="hljs-selector-attr">[-R]</span> group:owner test<span class="hljs-selector-class">.log</span><br><span class="hljs-function"><span class="hljs-title">chown</span><span class="hljs-params">(change owner)</span></span> <span class="hljs-built_in">-R</span>(递归执行) 用户组:用户名 文件/文件夹名（若非当前路径下的文件就写文件路径）<br></code></pre></td></tr></table></figure><p>至此，两人都可以访问/home/dev_shared文件夹了, 另外，用户可以自行检查自己所在的用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">groups</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网/校园网服务器设置代理</title>
    <link href="/2023/01/23/Linux_Note/%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2023/01/23/Linux_Note/%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="校园网内网服务器设置代理">校园网/内网服务器设置代理</h1><blockquote><p>部分学校服务器不连外网，导致无法使用git、无法装包等问题 仅适用于服务器和本地电脑(可连接外网)处于同一局域网下(如校园网)</p></blockquote><p>具体步骤如下：</p><h2 id="开启clash-allow-lan功能">1. 开启Clash Allow LAN功能</h2><p>本地电脑Clash，开启Allow LAN功能, 端口默认使用7890</p><p><img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/LinuxNoteImgs/202301241915447.png" width="50%"/></p><!-- ![202301241915447](https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/LinuxNoteImgs/202301241915447.png) --><h2 id="查看本地电脑ip及打开防火墙对应端口">2. 查看本地电脑IP及打开防火墙对应端口</h2><p>（1）本地电脑查看自身ip地址，可以使用ipconfig命令，如下ipv4地址为222.20.75.93</p><p><img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/LinuxNoteImgs/202301241915768.png" width="50%"/></p><!-- ![202301241915768](https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/LinuxNoteImgs/202301241915768.png) --><p>（2）部分电脑防火墙导致7890端口导致自身代理失败，需要在入站规则中增加一条端口，方法如下：</p><p><strong>windows安全中心-&gt;防火墙和网络保护-&gt;高级设置-&gt;入站规则-&gt;新建规则</strong></p><p><img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/LinuxNoteImgs/202301241915673.png" width="50%"/></p><!-- ![202301241915673](https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/LinuxNoteImgs/202301241915673.png) --><p><strong>只需要开放TCP即可，选择特定本地端口7890(端口号根据clash软件上的端口为准)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/LinuxNoteImgs/202301241915982.png" width="50%"/></p><!-- ![202301241915982](https://cdn.jsdelivr.net/gh/izhuhaoran/ImgsBed/LinuxNoteImgs/202301241915982.png) --><p>至此，本机已经可以被当做代理使用，接下来就是服务器如何使用代理</p><h2 id="服务器端使用代理">3. 服务器端使用代理</h2><p>服务器对于各种命令使用代理，本地地址加端口（这里是222.20.75.93:7890）即可。</p><ul><li><ol type="1"><li>对于<strong>git</strong>设置代理， 注意修改代理地址：</li></ol></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 设置代理</span><br>git config <span class="hljs-attr">--global</span> http<span class="hljs-selector-class">.proxy</span> http:<span class="hljs-comment">//222.20.75.93:7890</span><br>git config <span class="hljs-attr">--global</span> https<span class="hljs-selector-class">.proxy</span> https:<span class="hljs-comment">//222.20.75.93:7890</span><br><span class="hljs-comment">// 重置取消代理</span><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> http<span class="hljs-selector-class">.proxy</span><br>git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--unset</span> https.proxy<br></code></pre></td></tr></table></figure><ul><li><ol start="2" type="1"><li><strong>pip命令:</strong> 在 pip 命令的末尾加上 --proxy=代理IP:端口</li></ol></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pip</span> install robotframework --proxy=<span class="hljs-number">222.20.75.93:7890</span><br></code></pre></td></tr></table></figure><ul><li><ol start="3" type="1"><li>其他命令同样设置代理方法即可，等待后续搜索补充。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>git</tag>
      
      <tag>pip</tag>
      
      <tag>clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高版本Ubuntu安装低版本gcc</title>
    <link href="/2023/01/23/Linux_Note/%E9%AB%98%E7%89%88%E6%9C%ACUbuntu%E5%AE%89%E8%A3%85%E4%BD%8E%E7%89%88%E6%9C%ACgcc/"/>
    <url>/2023/01/23/Linux_Note/%E9%AB%98%E7%89%88%E6%9C%ACUbuntu%E5%AE%89%E8%A3%85%E4%BD%8E%E7%89%88%E6%9C%ACgcc/</url>
    
    <content type="html"><![CDATA[<h1 id="高版本ubuntu安装低版本gcc">高版本Ubuntu安装低版本gcc</h1><p>Ubuntu不同版本默认apt install gcc安装的gcc和g++版本不同，高版本Ubuntu无法直接通过apt install gcc安装低版本编译器，需要修改apt源，这里以Ubuntu22.04为例，给出安装gcc-5/gcc-7的简单方法</p><p><strong>1. 首先需要简单介绍常用国内apt源--&gt;阿里云和清华云(此步骤只是参考可略过)</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br> <br><span class="hljs-comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br> <br><span class="hljs-comment">## Pre-released source, not recommended.</span><br><span class="hljs-comment"># deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br> <br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy main restricted universe multiverse<br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-updates main restricted universe multiverse<br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-backports main restricted universe multiverse<br>deb https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/ubuntu/</span> jammy-security main restricted universe multiverse<br> <br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br> <br><span class="hljs-comment">## Pre-released source, not recommended.</span><br><span class="hljs-comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><br></code></pre></td></tr></table></figure><p>上面源中jammy标识为ubuntu22.04，若为其他版本Ubuntu，将对应jammy改为其他版本标识，如focal即可，常用的Ubuntu版本代号如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Ubuntu</span> <span class="hljs-number">22</span>.<span class="hljs-number">04</span>：jammy<br><span class="hljs-attribute">Ubuntu</span> <span class="hljs-number">20</span>.<span class="hljs-number">04</span>：focal<br><span class="hljs-attribute">Ubuntu</span> <span class="hljs-number">18</span>.<span class="hljs-number">04</span>：bionic<br><span class="hljs-attribute">Ubuntu</span> <span class="hljs-number">16</span>.<span class="hljs-number">04</span>：xenial<br></code></pre></td></tr></table></figure><p><strong>2. Ubuntu22.04默认安装gcc-11版本，如果需要安装低版本，可以修改apt源，添加低版本ubuntu源来安装</strong></p><p>使用下面命令修改apt源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>如要安装gcc-7，在sources.list文件末尾添加Ubuntu 20.04：focal的源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> focal main universe<br></code></pre></td></tr></table></figure><p>如要安装gcc-5，在sources.list文件末尾添加Ubuntu 16.04：focal的源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/ubuntu/</span> xenial main universe<br></code></pre></td></tr></table></figure><p>sources.list文件修改完毕后，执行以下命令加载源 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure></p><p>注意，有时update时会报错, 提示GPG error缺少公钥，多见于添加了xenial版本源</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">W: GPG error: http://mirrors.aliyun.com/ubuntu xenial InRelease: The <span class="hljs-keyword">following</span> signatures couldn<span class="hljs-string">&#x27;t be verified because the public key is not available: NO_PUBKEY 40976EAF437D05B5 NO_PUBKEY 3B4FE6ACC0B21F32</span><br><span class="hljs-string">E: The repository &#x27;</span>http://mirrors.aliyun.com/ubuntu xenial InReleas<span class="hljs-string">e&#x27; is not signed.</span><br><span class="hljs-string">N: Updating from such a repository can&#x27;</span>t be done securely, <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> therefore disabled <span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span>.<br>N: See apt-secure(<span class="hljs-number">8</span>) manpage <span class="hljs-keyword">for</span> repository creation <span class="hljs-keyword">and</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">configuration</span> details.<br></code></pre></td></tr></table></figure><p>此时，解决办法根据报错信息“NO_PUBKEY 40976EAF437D05B5 NO_PUBKEY 3B4FE6ACC0B21F32”导入对应公钥即可</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sudo apt-key adv <span class="hljs-attr">--keyserver</span> keyserver<span class="hljs-selector-class">.ubuntu</span><span class="hljs-selector-class">.com</span> <span class="hljs-attr">--recv-keys</span> <span class="hljs-number">40976</span>EAF437D05B5<br>sudo apt-key adv <span class="hljs-attr">--keyserver</span> keyserver<span class="hljs-selector-class">.ubuntu</span><span class="hljs-selector-class">.com</span> <span class="hljs-attr">--recv-keys</span> <span class="hljs-number">3</span>B4FE6ACC0B21F32<br></code></pre></td></tr></table></figure><p>然后，再次sudo apt-get update，之后就可以直接apt安装gcc对应版本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> apt install gcc-<span class="hljs-number">5</span><br><span class="hljs-attribute">sudo</span> apt install gcc-<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc/g++</tag>
      
      <tag>c/c++</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu gcc/g++默认版本切换</title>
    <link href="/2023/01/23/Linux_Note/gcc%E9%BB%98%E8%AE%A4%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"/>
    <url>/2023/01/23/Linux_Note/gcc%E9%BB%98%E8%AE%A4%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu中gccg默认版本切换">Ubuntu中gcc/g++默认版本切换</h1><p>ubuntu系统中可能安装了多个版本的gcc/g++ 如gcc-5，gcc-7, gcc-9等等，在使用时，我们可以在命令直接指定gcc/g++版本来确定使用哪个编译器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++-5 ./test.cpp -o <span class="hljs-built_in">test</span><br>g++-7 ./test.cpp -o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>此外，我们还可以通过包管理工具update-alternatives来设置默认gcc/g++版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置gcc优先级，最后的数字代表优先程度，数值越大，优先程度越高，可自行调整各版本的优先级</span><br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50<br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 70<br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置g++优先级</span><br>sudo update-alternatives  --install /usr/bin/g++ g++ /usr/bin/g++-5 50<br>sudo update-alternatives  --install /usr/bin/g++ g++ /usr/bin/g++-7 70<br>sudo update-alternatives  --install /usr/bin/g++ g++ /usr/bin/g++-9 90<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看gcc各版本优先级</span><br>sudo update-alternatives --config gcc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看g++各版本优先级</span><br>sudo update-alternatives --config g++<br></code></pre></td></tr></table></figure><p>如上的命令后，gcc-9和g++-9的优先级设为最高，默认使用该版本，如需检查默认gcc/g++版本，使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -v<br>g++ -v<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux_Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc/g++</tag>
      
      <tag>c/c++</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/23/hello-world/"/>
    <url>/2023/01/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
